#!/usr/bin/env python3
"""
Generated by DNNE - Main Entry Point
Metadata: None
"""

import sys
import argparse
from pathlib import Path

# Add current directory to Python path for imports
sys.path.insert(0, str(Path(__file__).parent))

import asyncio
import logging

from framework.base import GraphRunner
from nodes import *

def configure_logging(verbose=False):
    """Configure logging based on verbose flag"""
    if verbose:
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(message)s')
    else:
        # Only show WARNING and above for quiet mode
        logging.basicConfig(level=logging.WARNING, format='%(asctime)s - %(name)s - %(message)s')

async def main():
    """Main execution function"""
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='DNNE Generated Training')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Enable verbose batch-level logging')
    args = parser.parse_args()

    # Set global verbose flag for nodes to access
    import builtins
    builtins.VERBOSE = args.verbose
    configure_logging(args.verbose)

    print("üöÄ Starting DNNE Queue-Based Execution")
    if args.verbose:
        print("üìù Verbose mode enabled - showing all batch details")
    else:
        print("üìä Quiet mode - showing epoch summaries only")
    print("=" * 60)

    # Create nodes
    node_37 = MNISTDatasetNode_37("37")
    node_38 = BatchSamplerNode_38("38")
    node_40 = NetworkNode_40("40")
    node_50 = GetBatchNode_50("50")
    node_51 = LossNode_51("51")
    node_55 = EpochTrackerNode_55("55")
    node_44 = SGDOptimizerNode_44("44")
    node_45 = TrainingStepNode_45("45")

    # Create runner
    runner = GraphRunner()

    # Add nodes to runner
    runner.add_node(node_37)
    runner.add_node(node_38)
    runner.add_node(node_40)
    runner.add_node(node_50)
    runner.add_node(node_51)
    runner.add_node(node_55)
    runner.add_node(node_44)
    runner.add_node(node_45)

    # Wire connections
    connections = [
        ("37", "dataset", "38", "dataset"),
        ("37", "schema", "38", "schema"),
        ("40", "model", "44", "network"),
        ("44", "optimizer", "45", "optimizer"),
        ("38", "dataloader", "50", "dataloader"),
        ("38", "schema", "50", "schema"),
        ("50", "images", "40", "input"),
        ("40", "output", "51", "predictions"),
        ("51", "loss", "45", "loss"),
        ("50", "labels", "51", "labels"),
        ("50", "epoch_stats", "55", "epoch_stats"),
        ("51", "loss", "55", "loss"),
        ("51", "accuracy", "55", "accuracy"),
        ("45", "ready", "50", "trigger"),
    ]
    runner.wire_nodes(connections)

    # Run the graph
    try:
        # Run indefinitely (Ctrl+C to stop)
        await runner.run()
        # Or run for specific duration:
        # await runner.run(duration=10.0)  # Run for 10 seconds
    except KeyboardInterrupt:
        print('\nüõë Stopped by user')

    # Show final statistics
    print('\nüìä Final Statistics:')
    stats = runner.get_stats()
    for node_id, node_stats in stats.items():
        print(f'  {node_id}: {node_stats["compute_count"]} computations, '
              f'avg time: {node_stats["last_compute_time"]:.3f}s')


if __name__ == '__main__':
    asyncio.run(main())