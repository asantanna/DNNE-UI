#!/usr/bin/env python3
"""
Generated by DNNE - Manual Test of SYNC Implementation
"""

import sys
import argparse
from pathlib import Path

# Add current directory to Python path for imports
sys.path.insert(0, str(Path(__file__).parent))

import asyncio
import logging
import time

from framework.base import GraphRunner, QueueNode

def configure_logging(verbose=False):
    """Configure logging based on verbose flag"""
    if verbose:
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(message)s')
    else:
        # Only show WARNING and above for quiet mode
        logging.basicConfig(level=logging.WARNING, format='%(asctime)s - %(name)s - %(message)s')

# Simple test to validate SYNC concept
class MockGetBatchNode(QueueNode):
    """Mock GetBatch with trigger support"""
    
    def __init__(self, node_id: str):
        super().__init__(node_id)
        self.setup_inputs(required=["trigger"])
        self.setup_outputs(["batch_ready"])
        self.batch_count = 0
        
    async def compute(self, trigger) -> dict:
        self.batch_count += 1
        self.logger.info(f"Triggered batch generation #{self.batch_count} by signal: {trigger.get('signal_type', 'unknown')}")
        return {"batch_ready": f"batch_{self.batch_count}"}

class MockTrainingStepNode(QueueNode):
    """Mock TrainingStep with ready output"""
    
    def __init__(self, node_id: str):
        super().__init__(node_id)
        self.setup_inputs(required=["batch_ready"])
        self.setup_outputs(["ready"])
        self.step_count = 0
        
    async def run(self):
        """Send initial ready signal then process batches"""
        self.running = True
        self.logger.info(f"Starting node {self.node_id}")
        
        try:
            # Send startup ready signal
            ready_signal = {
                "signal_type": "ready",
                "timestamp": time.time(),
                "source_node": self.node_id,
                "metadata": {"phase": "startup"}
            }
            await self.send_output("ready", ready_signal)
            self.logger.info("Sent startup ready signal")
            
            # Process batches normally
            await super().run()
            
        except asyncio.CancelledError:
            self.logger.info(f"Node {self.node_id} cancelled")
            raise
        finally:
            self.running = False
    
    async def compute(self, batch_ready) -> dict:
        self.step_count += 1
        self.logger.info(f"Processing {batch_ready}, step #{self.step_count}")
        
        # Simulate training step
        await asyncio.sleep(0.1)
        
        # Send ready signal for next batch
        ready_signal = {
            "signal_type": "ready", 
            "timestamp": time.time(),
            "source_node": self.node_id,
            "metadata": {"phase": "training_complete", "step": self.step_count}
        }
        
        return {"ready": ready_signal}

async def main():
    """Test SYNC synchronization concept"""
    parser = argparse.ArgumentParser(description='SYNC Test')
    parser.add_argument('--verbose', '-v', action='store_true', help='Enable verbose logging')
    args = parser.parse_args()
    
    configure_logging(args.verbose)
    
    print("ðŸ§ª Testing SYNC-based Training Synchronization")
    print("=" * 60)
    
    # Create test nodes
    get_batch = MockGetBatchNode("get_batch")
    training_step = MockTrainingStepNode("training_step") 
    
    # Create runner
    runner = GraphRunner()
    runner.add_node(get_batch)
    runner.add_node(training_step)
    
    # Wire the SYNC connection: TrainingStep.ready -> GetBatch.trigger
    connections = [
        ("training_step", "ready", "get_batch", "trigger"),
        ("get_batch", "batch_ready", "training_step", "batch_ready")
    ]
    runner.wire_nodes(connections)
    
    # Run for a short test
    try:
        print("ðŸš€ Starting synchronized execution...")
        await runner.run(duration=5.0)  # Run for 5 seconds
    except KeyboardInterrupt:
        print('\nðŸ›‘ Stopped by user')
    
    # Show results
    print('\nðŸ“Š Test Results:')
    stats = runner.get_stats()
    for node_id, node_stats in stats.items():
        print(f'  {node_id}: {node_stats["compute_count"]} operations')

if __name__ == '__main__':
    asyncio.run(main())